<!doctype html>

<head>
</head>

<body style="margin: 0px;">
    <div id="status" style="position: absolute;height:200px;width:200px;top: 50%; left: 45%;">
            Polly Duff Kertis
    </div>
    <canvas id="main"></canvas>
</body>
<script>
var canvas = document.getElementById('main');
var ctx = canvas.getContext("2d");
var bounceSound = new Audio('kjick.wav');
var marbles = [];
var maxMarbles = 20;
var platforms = [];
var paused = false;
var animationSpeed = 0;
var ready = true;
var animationTimer = 0;
var debugMode = false;

window.addEventListener('load', function() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    //addMarbles(1);
    addPlatforms(2);
    addBaseline();

    setInterval(addMarble, 1000)

    animate();

}, false);

document.addEventListener('click', pause)

/**
 * Pause Animation
 */
function pause() {
    paused = !paused;
    if (paused) {
        document.getElementById('status').innerHTML = "PAUSED";
    } else {
        document.getElementById('status').innerHTML = "";
    }
    animate();
}

/**
 * Clear canvas
 */
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

/**
 * Add # marbles to the canvas at random x positions.
 * @param {Number} n
 */
function addMarbles(n) {
    for (var i = 0; i < n; i++) {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        marbles.push(new Marble(i, Math.floor(Math.random() * canvas.width) + 1, null, color));
    }
}

/**
 * Add # platforms to the canvas at random positions
 * @param {Number} n
 */
function addPlatforms(n) {
    for (var i = 0; i < n; i++) {
        var x = Math.floor(Math.random() * canvas.width) + 1;
        var y = Math.floor(Math.random() * canvas.height) + 1;
        var l = Math.floor(Math.random() * canvas.width / 2) + 1;
        platforms.push(new Platform(x, y, l));
    }
}

/**
 * Add a marble to the canvas in a random X position.
 */
function addMarble() {
    if (marbles.length < maxMarbles) {
        var color = '#000' //+ Math.floor(Math.random() * 16777215).toString(16);
        marbles.push(new Marble(marbles.length + 1, Math.floor(Math.random() * canvas.width) + 1, null, color));
    }
}

/**
 * Add a base platform at the bottom of the canvas.
 */
function addBaseline() {
    platforms.push(new Platform(0, canvas.height - 25, canvas.width));
}

/**
 * Advance animation timer and return whether the animation should occur
 * @return {Boolean}
 */
function advanceTimer() {
    if (animationTimer < animationSpeed) {
        animationTimer++
        return false;
    } else {
        animationTimer = 0;
        return true;
    }
}

/**
 * Animate a frame
 */
function animate() {
    if (!paused) requestAnimationFrame(animate);

    if (advanceTimer()) {
        clearCanvas();

        //draw all platforms
        for (var i = 0; i < platforms.length; i++) {
            platforms[i].draw();
        }
        //draw all marbles
        for (var i = 0; i < marbles.length; i++) {
            marbles[i].fall();
        }
        for (var i = 0; i < marbles.length; i++) {
            marbles[i].collision = marbles[i].detectCollisions();
        }
    }
}

/**
 * Constructor for Platform object
 * @param {Number} x      x position of platform's left edge
 * @param {Number} y      y position of platform's left edge
 * @param {Number} length length of platform
 */
function Platform(x, y, length) {
    var platform = this;
    platform.x = x;
    platform.y = y;
    platform.length = length;
    platform.endx = platform.x + platform.length;
    platform.draw = draw;
    platform.thickness = 1;

    function draw() {
        ctx.beginPath();
        ctx.lineWidth = platform.thickness;
        ctx.moveTo(platform.x, platform.y + platform.thickness / 2);
        ctx.lineTo(platform.endx, platform.y + platform.thickness / 2);
        ctx.closePath();
        ctx.stroke();
    }
}

/**
 * Constructs Marble Object
 * @param {Number} id
 * @param {Number} x
 * @param {Number} y
 */
function Marble(id, x, y, color) {
    var marble = this;
    var size = 5;
    var initialVelocity = 0.2;
    var weight = 2;
    marble.velocity = initialVelocity;
    marble.weight = weight;
    marble.id = id;
    marble.bouncingUp = false;
    marble.x = x || 0;
    marble.y = y || -size;
    marble.radius = size;
    marble.diameter = size * 2;
    marble.fall = fall;
    marble.bounceUp = bounceUp;
    marble.getClosestPlatform = getClosestPlatform;
    marble.getNextX = getNextX;
    marble.getNextY = getNextY;
    marble.onMarble = onMarble;
    marble.onPlatform = onPlatform;
    marble.detectCollisions = detectCollisions;
    marble.didCollideWithPlatform = didCollideWithPlatform;
    marble.opacity = 1;
    marble.color = color;
    marble.direction = Math.floor(Math.random() * 2) == 1 ? 1 : -1;
    marble.xspeed = 3 * marble.direction;
    marble.yspeed = 3;

    return marble;

    /**
     * Move the marble
     * @return
     */
    function fall() {
        marble.getClosestPlatform();
        marble.x = marble.getNextX();
        marble.y = marble.getNextY();
        draw(marble.x, marble.y);
    }

    /**
     * Bounce the marble in the air
     * @return {[type]} [description]
     */
    function bounceUp() {
        //turn on the bounce
        if (!marble.bouncingUp) {
            bounceSound.play();
            marble.bouncingUp = true;
            marble.yspeed = -marble.yspeed;
        }

        //the bounce will be complete when the marble's upward velocity has sufficiently slowed
        var bounceUpComplete = Math.abs(marble.yspeed) < 1;

        //send the ball up, decreasing marble.yspeed
        if (marble.bouncingUp && !bounceUpComplete) {

            //depending on the marble's weight, bounce it less (decrease the velocity more rapidly)
            for (var i = 0; i < marble.weight; i++) {
                marble.yspeed = marble.yspeed * (1 - marble.velocity);
            }
        }

        //turn gravity back on when the bounce is complete
        if (marble.bouncingUp && bounceUpComplete) {
            marble.bouncingUp = false;
            marble.yspeed = -marble.yspeed;
        }
    }

    /**
     * Tells us if the object is currently on any platform AND is not bouncingUp.
     * @param  {Object} object
     * @return {Boolean}
     */
    function onPlatform() {
        var isOnPlatform = false;
        platforms.forEach(function(platform) {
            if (marble.x >= platform.x - marble.radius / 2 &&
                marble.x <= platform.endx + marble.radius / 2 &&
                marble.y === platform.y - marble.radius) {
                isOnPlatform = true;
            }
        });
        return isOnPlatform;
    }

    /**
     * Detects whether the object is on top of any other object.
     * @return {Boolean}
     */
    function onMarble() {
        var isOnMarble = false;
        marbles.forEach(function(object) {
            if (marble !== object) {
                if (Math.abs(marble.x - object.x) <= marble.diameter && Math.abs(marble.y - object.y) <= marble.diameter) {
                    isOnMarble = true;
                }
            }
        })
        return isOnMarble;
    }

    /**
     * Returns true any time the object is sharing the same Y position as its closest platform.
     * @param  {Object} object
     * @return {Boolean}
     */
    function didCollideWithPlatform() {
        var result = marble.y === marble.closestPlatform.y - marble.radius;
        return result;
    }

    /**
     * Determines if the current object is about to collide with any other object (looks at Y AXIS)
     * @return {Object}
     */
    function detectCollisions() {
        var collision = false;
        marbles.forEach(function(object) {
            if (marble !== object) {
                if (Math.abs(marble.y - object.y + marble.yspeed) < marble.diameter && Math.abs(marble.x - object.x + marble.xspeed) < marble.diameter) {
                    collision = object;
                }
            }
        });
        return collision;
    }

    /**
     * Gets the next Y position for the object. If the object is about to hit a platform,
     * returns the difference between the object and the platform Y.
     * @param  {Object} object
     * @return {Number}
     */
    function getNextY() {
        if (marble.collision) {
            var collisionY = marble.y + (marble.collision.bouncingUp ? -Math.abs(marble.collision.y - marble.y) + marble.diameter : Math.abs(marble.collision.y - marble.y) - marble.diameter);

            if (marble.bouncingUp && !marble.collision.bouncingUp || !marble.bouncingUp && !marble.collision.bouncingUp && marble.collision.y < marble.y) marble.collision.bounceUp();
            if (!marble.bouncingUp && marble.collision.bouncingUp || !marble.bouncingUp && !marble.collision.bouncingUp && marble.y < marble.collision.y) marble.bounceUp();
        }

        if (marble.didCollideWithPlatform() || marble.bouncingUp) {
            bounceUp();
        } else {
            marble.yspeed = marble.yspeed * (1 + marble.velocity);
        }

        if (marble.y + marble.yspeed >= marble.closestPlatform.y - marble.radius) {
            return marble.closestPlatform.y - marble.radius;
        }
        return collisionY || marble.y + marble.yspeed;
    }

    /**
     * Gets the next X position for the object. If the object collides with the
     * sides of the canvas, it is reversed.
     * @return {Number}
     */
    function getNextX() {
        var isExact = false;

        if (marble.x < 0 + marble.radius || marble.x > canvas.width - marble.radius) {
            //resetMarble(marble.id)
            bounceSound.play();
            marble.direction *= -1;
            marble.xspeed *= -1;
        }

        //what happens when the x is already overlapping and a Y collision occurs? The collision becomes
        //continous and both of them are slowed by the repeated -1 / 1 action of the code below. 
        //how can we prevent the overlap without a hurky-jerky movement? This also causes direction and speed values to be misaligned

        if (marble.collision) {
            if (marble.direction > 0) {
                //the marble is rolling to the right
                if (marble.collision.direction > 0) {
                    //the marble is rolling faster than the collision and hit the left side
                    marble.collision.xspeed = marble.xspeed;
                } else {
                    //the collision hit the right side of the marble
                    marble.direction *= -1;
                    marble.xspeed *= -1;
                }
            } else {
                //the marble is rolling to the left
                if (marble.collision.direction > 0) {
                    //the collision hit the left side of the marble
                    marble.direction *= -1;
                    marble.xspeed *= -1;
                } else {
                    //the collision is rolling faster than the marble and hit the right side
                    marble.xspeed = marble.collision.xspeed;
                }
            }
            if (marble.onMarble() && Math.abs(marble.xspeed) < 1) {
                if (marble.x > marble.collision.x) {
                    marble.x++
                } else {
                    marble.x--
                }
            }
        }
        //if (marble.onMarble()) console.log(marble.id, marble.xspeed);
        if (Math.abs(marble.xspeed) > 0.4) {
             marble.xspeed *= 0.99;
        } else {
            marble.xspeed = 0;
        }
        return marble.x + marble.xspeed;
    }

    /**
     * Returns the closest platform which is below the object and within its x range.
     * @param  {Object} object
     * @return {Object}
     */
    function getClosestPlatform() {
        var currentPlatform;
        platforms.forEach(function(platform) {
            if (marble.x >= platform.x - marble.radius / 2 && marble.x <= platform.endx + marble.radius / 2 && platform.y - marble.radius >= marble.y) {
                if (!currentPlatform || platform.y < currentPlatform.y) {
                    currentPlatform = platform;
                }
            }
        });
        marble.closestPlatform = currentPlatform || platforms[platforms.length - 1];
    }

    /**
     * Returns true if the object's Y will surpass the closest platform on the next animation frame.
     * @param  {Object} object
     * @return {Boolean}
     */
    function didSettle(object) {
        if (object.y + object.yspeed > marble.closestPlatform.y - object.radius) {
            return true;
        }
        return false;
    }

    /**
     * Moves the marble back to the top of the canvas at a random X
     * @param  {Number} id
     * @return
     */
    function resetMarble(id) {
        marbles[id] = new Marble(id, Math.floor(Math.random() * canvas.width) + 1);
    }

    /**
     * Draw the marble
     * @param  {Number} centerX
     * @param  {Number} centerY
     */
    function draw(centerX, centerY) {
        ctx.beginPath();
        ctx.fillStyle = marble.color;
        ctx.arc(centerX, centerY, marble.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.closePath();

        if (debugMode) {
            ctx.beginPath();
            ctx.fillStyle = "black";
            ctx.rect(centerX - marble.radius, centerY - marble.radius, marble.diameter, marble.diameter);
            ctx.stroke();
            ctx.fillText(marble.id, centerX - 2, centerY + 2)
            ctx.closePath();
        }
    }

}
</script>

</html>
