<!doctype html>

<head>
</head>

<body style="margin: 0px;">
    <div id="status" style="position: absolute;height:100px;width:100px;top: 50%; left: 50%;"></div>
    <canvas id="main"></canvas>
</body>
<script>
var canvas = document.getElementById('main');
var ctx = canvas.getContext("2d");
var marbles = [];
var paused = false;
var animationSpeed = 0;
var ready = true;
var animationTimer = 0;
var debugMode = false;

window.addEventListener('load', function() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 20;

    addMarbles(10);

    //setInterval(addMarble, 200)

    animate();

}, false);

document.addEventListener('click', pause)

/**
 * Pause Animation
 */
function pause() {
    paused = !paused;
    if (paused) {
        document.getElementById('status').innerHTML = "PAUSED";
    } else {
        document.getElementById('status').innerHTML = "";
    }
    animate();
}

/**
 * Clear canvas
 */
function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

/**
 * Add # marbles to the canvas at random x positions.
 * @param {Number} n
 */
function addMarbles(n) {
    for (var i = 0; i < n; i++) {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        marbles.push(new Marble(i, Math.floor(Math.random() * canvas.width) + 1, null, color));
    }
}

/**
 * Add a marble to the canvas in a random X position.
 */
function addMarble() {
    if (marbles.length < maxMarbles) {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        marbles.push(new Marble(marbles.length + 1, Math.floor(Math.random() * canvas.width) + 1, null, color));
    }
}

/**
 * Advance animation timer and return whether the animation should occur
 * @return {Boolean}
 */
function advanceTimer() {
    if (animationTimer < animationSpeed) {
        animationTimer++
        return false;
    } else {
        animationTimer = 0;
        return true;
    }
}

/**
 * Animate a frame
 */
function animate() {
    if (!paused) requestAnimationFrame(animate);
    if (marbles[0].collision) {
        //debugger
    }

    if (advanceTimer()) {
        clearCanvas();

        //draw all marbles
        for (var i = 0; i < marbles.length; i++) {
            marbles[i].move();
        }

        for (var i = 0; i < marbles.length; i++) {
            marbles[i].detectCollisions();
        }

        for (var i = 0; i < marbles.length; i++) {
            marbles[i].draw();
        }

    }
}

/**
 * Constructor for Platform object
 * @param {Number} x      x position of platform's left edge
 * @param {Number} y      y position of platform's left edge
 * @param {Number} length length of platform
 */
function Platform(x, y, length) {
    var platform = this;
    platform.x = x;
    platform.y = y;
    platform.length = length;
    platform.endx = platform.x + platform.length;
    platform.draw = draw;
    platform.thickness = 1;

    function draw() {
        ctx.beginPath();
        ctx.lineWidth = platform.thickness;
        ctx.moveTo(platform.x, platform.y + platform.thickness / 2);
        ctx.lineTo(platform.endx, platform.y + platform.thickness / 2);
        ctx.closePath();
        ctx.stroke();
    }
}

/**
 * Constructs Marble Object
 * @param {Number} id
 * @param {Number} x
 * @param {Number} y
 */
function Marble(id, x, y, color) {
    var marble = this;
    var size = Math.floor(Math.random() * 60) + 10;
    var initialVelocity = 0.2;
    var weight = 2;
    marble.velocity = initialVelocity;
    marble.weight = weight;
    marble.id = id;
    marble.bouncingUp = false;
    marble.x = x || size;
    marble.y = y || size;
    marble.radius = size;
    marble.diameter = size * 2;
    marble.move = move;
    marble.draw = draw;
    marble.detectCollisions = detectCollisions;
    marble.bounceUp = bounceUp;
    marble.getNextX = getNextX;
    marble.getNextY = getNextY;
    marble.opacity = 1;
    marble.color = color;
    marble.xspeed = (Math.floor(Math.random() * 5) + 1);
    marble.yspeed = 3;

    return marble;

    /**
     * Move the marble
     * @return
     */
    function move() {
        marble.x = marble.getNextX();
        marble.y = marble.getNextY();
    }

    /**
     * Bounce the marble in the air
     * @return {[type]} [description]
     */
    function bounceUp() {
        //turn on the bounce
        if (!marble.bouncingUp) {
            bounceSound.play();
            marble.bouncingUp = true;
            marble.yspeed = -marble.yspeed;
        }

        //the bounce will be complete when the marble's upward velocity has sufficiently slowed
        var bounceUpComplete = Math.abs(marble.yspeed) < 1;

        //send the ball up, decreasing marble.yspeed
        if (marble.bouncingUp && !bounceUpComplete) {

            //depending on the marble's weight, bounce it less (decrease the velocity more rapidly)
            for (var i = 0; i < marble.weight; i++) {
                marble.yspeed = marble.yspeed * (1 - marble.velocity);
            }
        }

        //turn gravity back on when the bounce is complete
        if (marble.bouncingUp && bounceUpComplete) {
            marble.bouncingUp = false;
            marble.yspeed = -marble.yspeed;
        }
    }

    /**
     * Determines if the current object is about to collide with any other object (looks at Y AXIS)
     * @return {Object}
     */
    function detectCollisions() {
        var collision = null;
        marbles.forEach(function(object) {
            if (marble !== object) {
                var xdiff = marble.x - object.x;
                var ydiff = marble.y - object.y;
                var distance = Math.sqrt(Math.pow(xdiff, 2) + Math.pow(ydiff, 2));
                //if d > r0 + r1 the circles do not overlap. 
                //if d < r0 - r1 one circle is inside the other
                //if d = 0 and r1 = r2, the circles are coincident
                if (distance <= marble.radius + object.radius &&
                    distance >= Math.abs(marble.radius - object.radius)) {
                    collision = object;
                    var a = (Math.pow(marble.radius, 2) - Math.pow(collision.radius, 2) + Math.pow(distance, 2)) / (2 * distance);
                    var h = Math.sqrt(Math.pow(marble.radius, 2) - Math.pow(a, 2));
                    collision.x2 = marble.x + a * (collision.x - marble.x) / distance;
                    collision.y2 = marble.y + a * (collision.y - marble.y) / distance;
                    collision.x3a = collision.x2 + h * (collision.y - marble.y) / distance;
                    collision.x3b = collision.x2 - h * (collision.y - marble.y) / distance;
                    collision.y3a = collision.y2 - h * (collision.x - marble.x) / distance;
                    collision.y3b = collision.y2 + h * (collision.x - marble.x) / distance;
                }
            }
            marble.collision = collision;
        });
    }

    /**
     * Gets the next Y position for the object. If the object is about to hit a platform,
     * returns the difference between the object and the platform Y.
     * @param  {Object} object
     * @return {Number}
     */
    function getNextY() {
        if (marble.y < marble.radius || marble.y > canvas.height - marble.radius) {
            marble.yspeed *= -1;
        }
        if (marble.collision) {

        }
        return marble.y + marble.yspeed;
    }

    /**
     * Gets the next X position for the object. If the object collides with the
     * sides of the canvas, it is reversed.
     * @return {Number}
     */
    function getNextX() {
        if (marble.x < marble.radius || marble.x > canvas.width - marble.radius) {
            marble.xspeed *= -1;
        }
        if (marble.collision) {

        }
        return marble.x + marble.xspeed;
    }

    /**
     * Moves the marble back to the top of the canvas at a random X
     * @param  {Number} id
     * @return
     */
    function resetMarble(id) {
        marbles[id] = new Marble(id, Math.floor(Math.random() * canvas.width) + 1);
    }

    /**
     * Draw the marble
     * @param  {Number} centerX
     * @param  {Number} centerY
     */
    function draw() {
        ctx.beginPath();
        ctx.strokeStyle = marble.color;
        ctx.arc(marble.x, marble.y, marble.radius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();

        if (marble.collision) {
            ctx.beginPath();
            ctx.strokeStyle = "black";
            ctx.rect(marble.collision.x2 - 0.5, marble.collision.y2 - 0.5, 1, 1);
            ctx.fill();
            ctx.moveTo(marble.collision.x3a, marble.collision.y3a);
            ctx.lineTo(marble.collision.x3b, marble.collision.y3b);
            ctx.stroke();
            ctx.fillText(marble.id, marble.x, marble.y)
            ctx.closePath();

        }
    }

}
</script>

</html>
